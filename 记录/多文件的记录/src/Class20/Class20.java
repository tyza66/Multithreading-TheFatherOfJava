package Class20;

public class Class20 {
    /*
        多线程的七种执行状态
        初始化状态，运行状态，就绪状态，死亡状态，阻塞状态，超时状态，等待状态
        new了但是没有start的时候 只是新建状态
        调用了start方法，线程也不会被cpu立马的进行调度运行 cpu调度也是有一些算法的
        调用了start方法的线程处于就绪的状态
        当cpu调度到这个这个线程执行的时候 线程的状态就会从就绪状态变为运行状态
        当一个线程整个run方法的代码执行完毕，就意味着当前线程终止了 进入了终止状态（死亡状态）
        如果用了锁，线程没拿到锁就会处于一个阻塞状态
        被阻塞的线程需要唤醒
        如果被唤醒了 重新变成就绪状态之后等待cpu调度
        锁的升级过程是指将多个细粒度的锁转换为更少的粗粒度的锁，以减少内存开销，但同时也降低了并发性1。在Java中，锁的升级过程涉及到对象头2，对象头中有一部分用来存储Mark Word，它记录了对象的状态信息，包括哈希码、GC分代年龄、锁状态标志等。根据Mark Word中的锁状态标志，Java对象可以有以下几种锁状态：无锁、偏向锁、轻量级锁和重量级锁。当多个线程竞争同一个对象时，会根据不同情况进行不同方式的加锁和解锁操作，从而实现了自适应自旋和锁消除等优化技术。
        如果没有获得锁的话 会有一个锁的升级过程
        如果没有获得到锁 那么当前的线程会阻塞等待 后期唤醒的时候成本是非常非常高的
        持有锁的线程在释放锁的时候会唤醒正在阻塞的锁的线程（没有获取到锁的线程）
        后期需要用到CS无锁
        我们一旦调用了wait和join 又分为超时等待和等待状态 他们本质其实没太大差别
        join底层就是用的wait封装的
    */
}
